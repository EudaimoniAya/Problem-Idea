#### XSS(跨站脚本攻击)风险

XSS是攻击者将恶意脚本注入到网页中，让其他用户的浏览器执行这些脚本。比如将`<script>窃取用户信息</script>`发送到评论区，当其他用户点击浏览时信息就被窃取。这种XSS攻击根据作用形式不同分为三种类型：

* **存储型XSS：** 恶意脚本被永久存储在目标服务器上（如评论区），当用户访问时执行这是**最危险的XSS攻击**。如在论坛评论区中，攻击者输入`<script>窃取用户信息</script>`，评论被保存到数据库，当其他用户查看评论时脚本自动执行，用户的信息被窃取。
  但是在现代框架中默认都会转义HTML特殊字符，并进行输入过滤和输出编码，加上开发者的防护，可以让内容安全地显示。对此可以使用httpOnly字段，让JS无法读取，所以即使有XSS漏洞脚本也读不到Cookie。虽然浏览器发送请求时，仍然会自动携带这个Cookie（自动包括httpOnly Cookie在内的所有Cookie），但是无法通过`document.cookie`查看到
  即，**httpOnly Cookie绝不会被恶意脚本拿到，这是浏览器的强制安全限制。** 它是防御XSS窃取Cookie的第一道防线，处于被动防御阶段。

```python
  # httpOnly Cookie的设置
  response.set_cookie(
    key="session_id",
    value="abc123",
    httponly=True,    # JavaScript无法读取这个Cookie
    secure=True,      # 仅HTTPS传输
  )  
```

* **反射型XSS：** 恶意脚本作为请求的一部分，服务器将其反射回响应中，在用户浏览器中执行，这是**最常见**的XSS攻击。如攻击者诱导用户点击**恶意链接（链接指向了正常网站，但参数中包含了恶意脚本）**，之后用户点击后访问**正常网站**，网站服务器**反射**回参数中的恶意脚本，用户浏览器再执行这些脚本。

* **DOM型XSS：** 通过修改页面的DOM节点来执行恶意脚本。如前端JS处理URL参数时，出现`url: https://example.com/#<script>恶意代码</script>`，那么前端JS读取hash并动态插入页面，恶意脚本被执行。它的恶意代码的注入都发生在客户端，而不经过服务器，它利用的是JS中存在的漏洞。即DOM型XSS是**纯前端漏洞**，攻击载荷在URL的#部分或前端存储中，不经过服务器，由前端JS不安全地处理导致，但是其出错影响会影响到全局的安全。
  **所以对于后端开发来说，需要避免在API设计时加剧问题：需要始终转义从数据库读取到的用户内容、需要提供清晰的API文档，说明字段是否安全、需要考虑提供“安全版本”和“原始版本”的字段。**
  以上三种类型的防御，总结起来就是规范的问题：**对于XSS攻击，可以通过自动转义、输入限制、输出规范来预防其发生；也需要使用httpOnly Cookie、SameSite Cookie、控制权限来限制危害**；此外还可以使用CSP策略、安全头部、监控审计等措施额外加固。

#### CSRF风险

跨站请求伪造(Cross-Site Request Forgery, CSRF)，是一种攻击方式，攻击者诱导受害者进入第三方网站，在受害者不知情的情况下，以受害者的身份向被攻击网站发送恶意请求，其流程为：

* 用户已经登录了可信网站（例如银行网站），并保留了登录凭证（例如Cookie）。
* 攻击者构造一个恶意网站，其中包含向可信网站发送请求的代码（例如转账请求）。
* 用户访问恶意网站，恶意网站自动向可信网站发送请求，浏览器会默认携带用户的Cookie。
* 可信网站接收到请求，验证Cookie有效，误以为是用户自己的操作，执行了恶意请求。

它的**核心漏洞是服务器无法区分“用户的自愿请求”和“攻击者伪造的请求”，所以防御的关键是让服务器能够验证请求确实是用户自愿发出的**。有四种主流的CSRF防御方案：

* CSRF Token（最常用、最可靠）

* SameSite Cookie（现代、简单）

* 双重提交Cookie

* 验证Referer/Origin头部
