## 模块的惰性加载与实例化位置
### 惰性加载
惰性加载指在真正需要的时候才创建对象或加载资源。它的使用场景包括：
1. **资源消耗大**：如果对象的创建需要消耗大量资源（内存、CPU、IO等），并且可能不会立即使用，那么惰性加载可以推迟这些消耗，提高启动性能。
2. **不确定性**：如果对象可能在整个程序运行中都不会被使用，那么惰性加载可以避免不必要的资源占用。
3. **循环依赖**：有时模块之间可能存在循环依赖，惰性加载可以帮助打破这种循环。
4. **动态配置**：如果对象的创建依赖于运行时才能确定的配置，那么惰性加载是必要的。
在运维层面，如配置和日志，通常希望在程序启动时就初始化，因为它们是基础服务，几乎所有的其他模块都会使用，而且初始化开销相对较小。所以，立即加载是合理的。
### 在`__init__.py`或模块内部创建实例 vs 调用方自行创建实例
这取决于模块的设计意图：
1. **在`__init__.py`或模块内部创建实例**：适用于整个模块只需要一个实例（单例），并且希望模块的使用者直接使用这个实例，而不关心其创建过程。例如，日志模块通常提供一个全局的logger实例。
2. **只在模块内部定义类，由调用方自行创建实例**：适用于需要多个不同配置的实例，或者实例的创建需要调用方提供参数的情况。例如，一个数据库连接池，不同的服务可能需要连接到不同的数据库，因此需要不同的实例。
### 单例模式的实现和暴露方式
单例模式通常用于确保一个类只有一个实例，并提供一个全局访问点。在Python中，可以通过模块级别的变量来实现单例（因为模块在第一次导入时会被缓存）。所以，在模块中创建一个实例并导出，就可以实现单例。
但是，**单例并不总是好的，它可能隐藏依赖关系，导致代码难以测试**。因此，需要权衡。
另一种做法是使用依赖注入，将单例实例作为参数传递给需要使用它的函数或类，这样在测试时可以替换为模拟对象。
**背后的工程思想：**
1. **单一职责原则**：一个模块或类应该只有一个引起变化的原因。将实例创建和使用分离，可以使模块更专注于其核心功能。
2. **依赖倒置原则**：高层模块不应该依赖低层模块，二者都应该依赖抽象。通过暴露接口（抽象基类）而不是具体类，可以降低耦合。
3. **控制反转**：将对象的创建责任从模块内部转移到外部（例如使用工厂模式或依赖注入容器），可以增加灵活性。
4. **可测试性**：如果模块内部直接创建实例，那么在测试时很难替换为模拟对象。通过将实例作为参数传递（依赖注入），可以更容易地进行测试。


## RAG
### Zero-shot思想
Zero-shot学习（Zero-shot Learning）是指在训练阶段不存在与测试阶段完全相同的类比，但是模型可以**使用训练过的知识来推广**到测试集中的新类别上。
这种能力被称为“**零样本**”学习，因为模型在训练时从未见过测试集中的新类别，在模型训练和提示词优化中均有体现。
**在模型训练中**：已知马（四脚兽）、虎（有条纹）、熊猫（黑白色）的特征，但是未训练过斑马的数据。此时告知模型斑马是四脚兽、有黑白色条纹，那么模型就可以在已知数据中推理，从而识别斑马。
**在提示词优化中**：Zero-shot思想用于**基于已训练的能力**，不提供任何示例，仅通过语言去描述任务的要求、目标和约束，**让模型直接生成结果**。即“用语言定义任务，解放（信任）模型的预训练知识”。
### Few-shot思想
Few-shot学习（Few-shot Learning）是指少样本学习，当模型在学习了一定类别的大量数据后，对于新的类别，只需要少量的样本就能快速学习，对应的有one-shot learning，单样本学习，也算样本少到为一的情况下的一种few-shot learning。
**在模型训练中（相似度判断方法）**：基于**少量企鹅样本**并结合相似度判断，推论未知图片内含“企鹅”
**在提示词优化中**：Few-shot主要用于基于少量示例，让模型参考示例回答。即”用示例定义任务，在模型的预训练知识的基础上，提升模型回答的对齐程度（如参考示例的格式）“

