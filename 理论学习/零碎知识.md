## 模块的惰性加载与实例化位置
### 惰性加载
惰性加载指在真正需要的时候才创建对象或加载资源。它的使用场景包括：
1. **资源消耗大**：如果对象的创建需要消耗大量资源（内存、CPU、IO等），并且可能不会立即使用，那么惰性加载可以推迟这些消耗，提高启动性能。
2. **不确定性**：如果对象可能在整个程序运行中都不会被使用，那么惰性加载可以避免不必要的资源占用。
3. **循环依赖**：有时模块之间可能存在循环依赖，惰性加载可以帮助打破这种循环。
4. **动态配置**：如果对象的创建依赖于运行时才能确定的配置，那么惰性加载是必要的。
在运维层面，如配置和日志，通常希望在程序启动时就初始化，因为它们是基础服务，几乎所有的其他模块都会使用，而且初始化开销相对较小。所以，立即加载是合理的。
### 在`__init__.py`或模块内部创建实例 vs 调用方自行创建实例
这取决于模块的设计意图：
1. **在`__init__.py`或模块内部创建实例**：适用于整个模块只需要一个实例（单例），并且希望模块的使用者直接使用这个实例，而不关心其创建过程。例如，日志模块通常提供一个全局的logger实例。
2. **只在模块内部定义类，由调用方自行创建实例**：适用于需要多个不同配置的实例，或者实例的创建需要调用方提供参数的情况。例如，一个数据库连接池，不同的服务可能需要连接到不同的数据库，因此需要不同的实例。
### 单例模式的实现和暴露方式
单例模式通常用于确保一个类只有一个实例，并提供一个全局访问点。在Python中，可以通过模块级别的变量来实现单例（因为模块在第一次导入时会被缓存）。所以，在模块中创建一个实例并导出，就可以实现单例。
但是，**单例并不总是好的，它可能隐藏依赖关系，导致代码难以测试**。因此，需要权衡。
另一种做法是使用依赖注入，将单例实例作为参数传递给需要使用它的函数或类，这样在测试时可以替换为模拟对象。
**背后的工程思想：**
1. **单一职责原则**：一个模块或类应该只有一个引起变化的原因。将实例创建和使用分离，可以使模块更专注于其核心功能。
2. **依赖倒置原则**：高层模块不应该依赖低层模块，二者都应该依赖抽象。通过暴露接口（抽象基类）而不是具体类，可以降低耦合。
3. **控制反转**：将对象的创建责任从模块内部转移到外部（例如使用工厂模式或依赖注入容器），可以增加灵活性。
4. **可测试性**：如果模块内部直接创建实例，那么在测试时很难替换为模拟对象。通过将实例作为参数传递（依赖注入），可以更容易地进行测试。