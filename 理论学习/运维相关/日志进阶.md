# 一、logging
以往在输出程序运行信息到控制台时，经常使用`print()`函数，虽然简单方便，但是输出的信息却很有限。所以在大型项目中使用`logging`库，比起`print()`要更加方便管控。
`logging`有5种不同级别的日志：DEBUG < INFO < WARNING < ERROR < CRITICAL，其中DEBUG和INFO通常不显示，如果希望显示那需要另外通过`basicConfig`的`level`设置：
```python
logging.debug("DEBUG")  # 获取详细信息，通常只在诊断问题时才需要关注  
logging.info("INFO")    # 用于确认程序按预期运行  
logging.warning("WARNING")  # 表示发生了意外情况，但程序仍然能继续运行  
logging.error("ERROR")  # 发生了更严重的意外情况，程序无法使用某些功能，如磁盘空间不足  
logging.critical("CRITICAL")    # 非常严重的错误，会导致程序无法继续运行
# 未配置等级则只显示下面三个日志

logging.basicConfig(level=logging.DEBUG)
```
此外还有很多字段：`filename`可以将日志输出到指定文件中；`encoding`设置编码；`filemode`设置文件模式，如果为`w`只写模式可以让日志在程序每次运行时重写而不是追加；`format`字段可以设置日志格式化输出信息：
```python
logging.basicConfig(format='%(levelname)s (%(asctime)s): %(message)s (Line: %(lineno)d [%(filename)s])',  
    datefmt='%I:%M:%S %p',  
    level=logging.DEBUG,  
    filename="my_log.log")
```
在`format`中，可以像写模板一样在其中插入希望输出的信息（是代码、系统相关，而不是方法内部逻辑相关），官方文档中给出了很多字段，要显示时字符串类型时可以通过`%(logging官方提供的字段)s`，要显示时数值类型时可以通过`%(logging官方提供的字段)d`。其中时间字段`%(asctime)s`的格式可以通过`datefmt`来设置。
另外，`logging`中输出的内容，可以像`print()`一样插入变量：
```python
int: x = 5 + 8
logging.info("The answer is %s", x)   # 向后兼容，旧版本写法
logging.info(f"The answer is {x}")    # 新版本写法
```
然后需要注意的是：`logging.basicConfig()`是对整个Python进程内的**根日志记录器（root logger）的一次性配置。一旦执行，它就对后续所有通过logging模块进行的日志调用都生效，无论这些调用来自哪个模块或包**。所以为了保证所有的日志行为都符合预期，需要确保在执行第一条日志记录语句前完成（否则之后就会按照第一条日志记录的基础配置，**后续的配置都会被忽略**）。**因此通常把`logging.basicConfig()`的配置语句放在程序入口附近。**

# 二、loguru
`loguru`是不同于Python内置的`logging`的第三方库，它在底层设计上**完全兼容**标准`logging`模块，它让日志记录更为简便，能够极大提升效率。但是在一些极为深入或冷门的定制场景下，高度模块化的标准`logging`可能具有更强的微调能力。**所以`loguru`是对`logging`在编程人员体验方向的”包装“和”改良“，而非”取代“**，就像自行车的自动挡和手动挡一样。
此外，并非所有时候都可以使用第三方库，在某些封闭环境中（物理隔离场景，如军工系统、涉密单位；强安全策略场景，如金融机构交易系统、医疗健康数据处理系统；资源/硬件受限场景，如物联网设备、车载系统；遗留/固化系统场景，如大企业稳定运行多年的核心业务系统）是做不到或者非常麻烦的。
### 1. 基础使用
`loguru`有7种日志：trace < debug < info < success < warning < error < critical，它们的配置几乎都能用`logger.add()`方法完成，它会在`logger`中**增加一个新的配置**。比如需要把日志记录进`msg.log`中时，只需要把文件名作为参数调用`add()`方法，就能把日志放进文件里。但是因为**在控制台输出日志又是另外的一个默认配置**，所以不像`logging`，写了`filename`字段后日志就不在控制台输出了，当需要只在文件中记录日志时可以在`logger.add()`执行前调用`logger.remove()`清除所有配置。需要清除单个配置时，`logger.add()`方法会返回一个`handler id`，可以将其传递给`logger.remove()`清除某个配置（实际使用中几乎不清除`handler`配置）。
此外，`logger`还能附加自定义的属性，可以通过`bind()`方法生成一个子`logger`
```python
# 通过format中的extra字段可以显示子logger自定义添加的属性
logger.add(
	sys.stdout,   # 在控制台输出
	format="<level>{time}</level> - {level} - <YELLOW>{message}</YELLOW> - {extra}"
)

child = logger.bind(foo="bar", hello="world")
child.info("msg from child info")
```
### 2. 上下文管理器
使用`loguru`可以在with语句中使用`contextualize`上下文管理器，可在一段代码的日志中添加某个参数：
```python
logger.add(sys.stdout, level="TRACE",  
           format="{time} - {level} - {message} - {extra}")
with logger.contextualize(programmer="want"):  
    logger.trace("trace message")  
    logger.debug("debug message")  
    logger.info("info message")  
    logger.success("success message")  
    logger.warning("warning message")  
    logger.error("error message")  
    logger.critical("critical message")
    
"""输出结果为；
2026-01-06T00:46:03.127290+0800 - TRACE - trace message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - DEBUG - debug message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - INFO - info message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - SUCCESS - success message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - WARNING - warning message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - ERROR - error message - {'programmer': 'want'}
2026-01-06T00:46:03.127290+0800 - CRITICAL - critical message - {'programmer': 'want'}
"""
```
此外也可以使用装饰器`@logger.contextualize()`添加想要的属性，这样被装饰的函数中所有日志都会被附加上添加的属性。
### 3. 异常处理
当程序发生异常时可以使用`loguru.exception()`方法来记录下try-except捕捉到异常时整个函数栈的信息：
```python
try:  
    1 / 0  
except ZeroDivisionError:  
    logger.exception("get exception")
    
"""输出结果为：
2026-01-06T00:57:40.582998+0800 - ERROR - get exception - {}
Traceback (most recent call last):

> File "E:\Code\loggingTest\loguru_test\guru.py", line 20, in <module>
    1 / 0

ZeroDivisionError: division by zero
"""
```
也可以在with语句中使用`loguru.catch()`来自动记录异常：
```python
with logger.catch(ZeroDivisionError, level="WARNING"):  
    1 / 0
    
"""输出结果为：
2026-01-06T00:59:12.828300+0800 - WARNING - An error has been caught in function '<module>', process 'MainProcess' (13592), thread 'MainThread' (11028): - {}
Traceback (most recent call last):

> File "E:\Code\loggingTest\loguru_test\guru.py", line 25, in <module>
    1 / 0

ZeroDivisionError: division by zero
"""
```
且类似于上下文管理器，`catch()`也可以用作装饰器`@loguru.catch()`

# 三、进阶

## 1. 结构化日志
结构化日志的核心是**将日志内容从一段”纯文本“转换为一个携带明确键值对的”字典“或”JSON“对象**。这使得日志可以被日志收集系统（如ELK、Loki）高效地解析、索引和查询，例如轻松找出所有`user_id="123"`且`action="login_failed"`的日志。**但是它不适合人类阅读，所以大多数专业日志系统会同时支持人类可读和机器可读的格式化器**。
对于logging，虽然标准库原生不支持结构化日志，但可以通过自定义Formatter和Filter来实现。关键是要展示如何将字典等结构化数据转换为日志系统能处理的格式。对于loguru，它的serialize参数和extra字段让结构化变得简单很多，这是它的优势所在。
### (1) `logging`模块实现结构化日志
虽然标准库的`logging`没有提供结构化日志，但是可以通过扩展`LogRecord`、自定义`Formatter`和`Filter`来手动实现。其核心思路在于：利用`logging.loggerAdapter`或`extra`参数为每条日志记录添加上下文字段，然后通过自定义的`JSONFormatter`将这些字段输出为JSON字符串。
#### a. `logging.Formatter`及其子类
`logging.Formatter` 的子类可以定制日志记录的格式，在源码中它的注释为：
```python 
"""Formatter instances are used to convert a LogRecord to text.
...
The Formatter can be initialized with a format string which makes use of  
knowledge of the LogRecord attributes. Currently, the useful  
attributes in a LogRecord are described by:  
  
%(name)s            Name of the logger (logging channel)  
%(levelno)s         Numeric logging level for the message (DEBUG, INFO,  
                    WARNING, ERROR, CRITICAL)
%(levelname)s       Text logging level for the message ("DEBUG", "INFO",  
                    "WARNING", "ERROR", "CRITICAL")
...
"""
```
整个注释主要提供了两点信息：
1) 它的实例能够将日志记录`LogRecord`转换成人类能懂的字符串，即**最后输出的日志就是由`Formatter`格式化后生成的字符串**。
2) `Formatter`实例格式化字符串使用的属性，都是**沿用了`LogRecord`对象的属性**，它们都是官方提供的。在之前的`logging`笔记中，`basicConfig`的`format`字段可以使用`%(字段名)s`来显示对应参数，而这些参数使用的正是`Formatter`支持的字段。**这是因为`basicConfig`是一个方便的用来快速配置根日志记录器。其参数`format`会在`basicConfig`内部被用来初始化一个`Formatter`对象（仅第一次生效），然后`Formatter`实例绑定到`Handler`实例上，`Handler`实例再绑定到`Logger`上**。
   **Q：**`basicConfig`仅第一次调用时生效，这个模式很像单例，那么它是单例模式吗？另外既然`Formatter`实例由它的`format`属性来初始化，那是否代表`Formatter`也是单例？
   **A：**`basicConfig`仅第一次调用时生效，之前笔记解释是根日志记录器（root logger）会保存首个配置，忽略之后的配置。**但是当`basicConfig`的`force`参数为`True`时，`basicConfig`会移除现有的处理器`Hendler`，重新获取，它的实现通过全局的”已配置“实现**。
```python
# basicConfig() 的源码，首先就会判断 force 字段的值，为真就会清除根Logger的所有处理器
if force:  
    for h in root.handlers[:]:  
        root.removeHandler(h)  
        h.close()
```
   虽然行为很像单例模式，但其原理并非单例，同样由它全局配置的`Formatter`也并非单例，代码中也可以直接通过`Formatter`来创建实例。所以存在一个根日志处理器，但是未来它的具体样式是什么，要看之后`basicConfig`的`force`字段以及它创建出的`Formatter`实例。
```python
# 第一次调用 
basicConfiglogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')  
  
# 获取 root logger 的处理器  
root_logger = logging.getLogger()  
handlers = root_logger.handlers  
print(handlers[0].formatter)  # 第一个 formatter  

# 强制重新配置  
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(message)s', force=True)  
  
# 重新获取处理器（因为 force 会先移除现有的处理器）  
root_logger = logging.getLogger()  
handlers = root_logger.handlers  
print(handlers[0].formatter)  # 新的 formatter
```
总之，`logging.Formatter`的作用就是将日志信息转换成字符串，这个类里面实现了很多关于格式化转换的方法：`format`、`formatTime`、`formatMessage`、`formatStack`、`formatException`，其中最常用的将日志转换为字符串的就是`format`。
另外，当没有特别配置（`basicConfig`没有设置`format`字段）时，会使用默认的`Formatter`，这点在源码中（`Formatter`类下面第一条语句）也有体现，这解释了为什么`Handler`未配置`Formatter`时，类似于`logging.error()`之类的语句执行后，再配置就无效了，因为内部有默认的`Formatter`：
```python
#   The default formatter to use when no other is specified  
#  
_defaultFormatter = Formatter()
```
但是`Formatter`仍然存在一些定制化需求无法满足的场景（动态格式、增强上下文、特殊格式、安全过滤、性能优化、适配器模式等）这时就需要它的子类来添加属性或是重写`format()`方法来实现。
#### b. `logging.Formatter`子类配合`extra`参数
上一点中介绍了想要更加个性化的`Formatter`，可以通过创建自定义的`Formatter`并重写其`format()`方法来实现：
```python
import logging  
import json  
  
  
# 1. 创建一个自定义的Formatter，将日志记录转换为JSON  
class JSONFormatter(logging.Formatter):  
    def format(self, record):  
        # 构建一个标准字典结构  
        log_record = {  
            'timestamp': self.formatTime(record),  
            'level': record.levelname,  
            'logger': record.name,  
            'module': record.module,  
            'function': record.funcName,  
            'line': record.lineno,  
            'message': record.getMessage(),  # 获取格式化后的消息主体  
        }  
  
        # 获取通过extra参数传入的额外字段  
        # extra字段不会存储在record.extra中，而是直接作为record的属性  
        # 这里先过滤出非内置的属性  
        builtin_attrs = {  
            'args', 'asctime', 'created', 'exc_info', 'exc_text',  
            'filename', 'funcName', 'levelname', 'levelno', 'lineno',  
            'module', 'msecs', 'message', 'msg', 'name', 'pathname',  
            'process', 'processName', 'relativeCreated', 'stack_info',  
            'thread', 'threadName'  
        }  
  
        # 遍历record的所有属性，找出通过extra传入的自定义字段  
        extra_fields = {}  
        for key, value in record.__dict__.items():  
            if key not in builtin_attrs and not key.startswith('_'):  
                extra_fields[key] = value  
  
        # 将额外字段合并到日志记录中  
        if extra_fields:  
            log_record.update(extra_fields)  
  
        # 将字典序列化为JSON字符串  
        return json.dumps(log_record, ensure_ascii=False)  
  
  
# 2. 配置Handler和Formatter  
log_handler = logging.StreamHandler()  
log_handler.setFormatter(JSONFormatter())  # 使用自定义的JSON格式化器  
  
logger = logging.getLogger('my_app')  
logger.setLevel(logging.INFO)  
logger.addHandler(log_handler)  
  
# 3. 记录日志时，通过extra参数传递结构化字段  
logger.info('User login successful', extra={  
    'user_id': 'u12345',  
    'ip': '192.168.1.100',  
    'action': 'login'  
})
```
当在记录日志时，首条消息默认为`msg`字段，用户添加进去的`extra`参数字典在传入时不是作为属性存在，即无法通过`record.extra`获取到新增参数，**它们直接被添加到了`record`对象的`__dict__`这个字典中**，所以上述代码就是通过遍历该字典，找到额外属性提取处理再合并到`log_record`中，这就实现了添加信息。**重写的`format()`将内置属性与新增属性合并后，以JSON形式格式化地输出**。
#### c. `LoggerAdapter`绑定公共上下文避免每次添加`extra`
`logging.LoggerAdapter` 是 logging 模块提供的一个**适配器类**，用于在不修改 Logger 对象的情况下，为所有日志记录**自动添加额外的上下文信息**。它在源码中的注释为：
```python
class LoggerAdapter(object):
	"""  
	An adapter for loggers which makes it easier to specify contextual  
	information in logging output.  
	"""
	def __init__(self, logger, extra=None):
	"""
	Initialize the adapter with a logger and a dict-like object which  
	provides contextual information. This constructor signature allows  
	easy stacking of LoggerAdapters, if so desired.
	"""
	    self.logger = logger  
	    self.extra = extra  
  
	def process(self, msg, kwargs):  
    """  
    Process the logging message and keyword arguments passed in to    
    a logging call to insert contextual information. You can either    
    manipulate the message itself, the keyword args or both. Return    
    the message and kwargs modified (or not) to suit your needs.  
    Normally, you'll only need to override this one method in a    
    LoggerAdapter subclass for your specific needs.    
    """    
    kwargs["extra"] = self.extra  
    return msg, kwargs
```
可见**它就是为了更方便地输出特定的上下文信息的一个类**，初始化它只需要一个传入的`logger`和包含额外信息的字典。然后**其内部的`process`方法将额外参数提取出来，合并进返回值中，通常情况在子类中重写该方法就能满足特定需求**。
在上一节使用的方法中，需要在每次日志调用时传入`extra`：
```python
logger.info('Request started', extra={'request_id': request_id, 'user_id': user_id})
logger.info('Processing data', extra={'request_id': request_id, 'user_id': user_id})
logger.info('Request finished', extra={'request_id': request_id, 'user_id': user_id})
```
这时如果使用`LoggerAdapter`，它接收logger并加入了额外信息后实例化出一个适配器，那么它就可以在后续作为logger来使用，后续在调用它记录日志时就能够等价于每次手动添加`extra`。就像FastAPI的依赖注入中，小依赖项加一些信息组合又变成一个大依赖项一样。
```python
def process_request(request_id, user_id):
    # 创建 adapter，绑定上下文
    adapter = logging.LoggerAdapter(
        logger, 
        {'request_id': request_id, 'user_id': user_id}
    )
    # 此时所有日志自动携带 request_id 和 user_id 参数 
    adapter.info('Request started')
    adapter.info('Processing data')
    adapter.info('Request finished')
```
但是，**适配器只是负责管理上下文**，让额外参数统一加在一起，当作一个`logger`来调用记录日志。它干的事情就是把工厂方法传进来的额外参数（工厂模式）解包，并加入到内置参数中。但是**因为`Formatter`并没有处理这些字段的功能，所以需要将其子类化并重写format方法，使其能够动态地将这些额外参数加入的日志字符串中**。
#### d. `LoggerAdapter`结合`Formatter`实现格式化输出
所以要实现结构化输出的完整流程是：创建适配器实例，让适配器自带能使用的额外参数，再创建格式化工具子类，重写其`format()`方法，在新写的模板中使用额外参数。
```python
import logging  
import json  
  
  
# 1. JSON格式化器（同上一小节）
class JSONFormatter(logging.Formatter):  
    """将日志格式化为JSON格式"""  
  
    def format(self, record):  
        # 构建基础JSON结构  
        log_data = {  
            'timestamp': self.formatTime(record),  
            'level': record.levelname,  
            'logger': record.name,  
            'message': record.getMessage(),  
        }  
  
        # 添加extra参数中的所有字段  
        for key, value in record.__dict__.items():  
            # 过滤掉内置属性  
            if key not in ['args', 'asctime', 'created', 'exc_info', 'exc_text',  
                           'filename', 'funcName', 'levelname', 'levelno', 'lineno',  
                           'module', 'msecs', 'msg', 'name', 'pathname',  
                           'process', 'processName', 'relativeCreated', 'stack_info',  
                           'thread', 'threadName', 'message']:  
                log_data[key] = value  
  
        # 如果有异常信息，添加到JSON中  
        if record.exc_info:  
            log_data['exception'] = self.formatException(record.exc_info)  
  
        return json.dumps(log_data, ensure_ascii=False, default=str)  
  
  
# 2. 适配器工厂  
class AdapterFactory:  
    """适配器工厂，创建不同类型的适配器"""  
  
    @staticmethod  
    def create_request_adapter(logger, **context_fields):  
        """创建请求适配器"""  
  
        class RequestAdapter(logging.LoggerAdapter):  
            def process(self, msg, kwargs):  
                # 合并适配器的上下文到extra中  
                if 'extra' not in kwargs:  
                    kwargs['extra'] = {}  
                kwargs['extra'].update(self.extra)  
                return msg, kwargs  
  
        return RequestAdapter(logger, context_fields) 
  
  
# 3. 简单使用  
if __name__ == "__main__":  
    # 3.1 创建logger并设置JSON格式化器  
    logger = logging.getLogger("my_app")  
    logger.setLevel(logging.INFO)  
  
    # 添加控制台处理器  
    handler = logging.StreamHandler()  
    handler.setFormatter(JSONFormatter())  
    logger.addHandler(handler)  
  
    # 3.2 使用工厂创建适配器  
    factory = AdapterFactory()  
  
    # 创建请求适配器  
    request_adapter = factory.create_request_adapter(  
        logger,  
        request_id="REQ-001",  
        user_id="USER-123",  
        client_ip="192.168.1.100",  
        service="auth_service"  
    )  
  
    # 3.3 使用适配器记录日志（自动携带额外参数）  
    request_adapter.info("用户登录成功")  
    request_adapter.warning("API调用频率过高", extra={'rate_limit': 50})
    
    
"""输出结果为：
{"timestamp": "2026-01-06 07:07:32,191", "level": "INFO", "logger": "my_app", "message": "用户登录成功", "request_id": "REQ-001", "user_id": "USER-123", "client_ip": "192.168.1.100", "service": "auth_service"}
{"timestamp": "2026-01-06 07:07:32,191", "level": "WARNING", "logger": "my_app", "message": "API调用频率过高", "rate_limit": 50, "request_id": "REQ-001", "user_id": "USER-123", "client_ip": "192.168.1.100", "service": "auth_service"}    
"""
```
另外，如果`print()`函数和`adapter`同时使用的话，很可能会出现不同步的问题，因为`print()`默认输出到 `sys.stdout`，`logging.StreamHandler()`默认输出到 `sys.stderr`，这两个是不同的输出流，操作系统不保证它们的输出顺序完全一致。**所以一旦使用了专业的日志系统，就应该避免使用`print()`来输出调试或提示信息：用`logger.debug()`替代调试用的`print()`；用`logger.info()`替代信息性的`print()`；需要上下文时，使用`LoggerAdapter`。** 
#### e. `logging.Handler`和`Logger`
`logging`库有以下的核心组件：
* `Logger`：日志记录器，应用程序调用logger来记录日志，并由其根据级别决定日志是否被处理，它**可以设置多个`Handler`**。
* `LoggerAdapter`：日志适配器，是`Logger`的包装，能够添加额外上下文。但是它**不能够处理输出，只能增强日志记录**。
* `Handler`：处理器，决定日志输出到哪里（控制台、文件、网络等），**每个`Handler`可以有自己的`Formatter`和`Filter`**。
* `Formatter`：格式化器，将`LogRecord`转换为字符串，**最终的日志输出格式由它决定**。
* `Filter`：过滤器，属于可选组件，用于过滤日志。
在日志系统中，通常需要设置日志记录器`Logger`：
```python
# 创建logger
logger = logging.getLogger('my_app')
logger.setLevel(logging.INFO)  # 设置日志级别
```
**Q：** 最基础的日志输出方法：使用`logging.xxxx`，先用`logging.basicConfig()`设置参数，然后通过`logging.info()`等完成日志输出。但是根据解释，`Formatter`需要注册进`Handler`，`Handler`需要注册进`Logger`，那么既然`logging.basicConfig()`通过`format`字段初始化了`Formatter`，那么它就一定会创建`Handler`实例并注册进去，且会继续创建`Logger`实例将`Handler`实例注册进去，否则格式化器的配置将无法作用。**那么是不是`logging.xxxx`方法只是官方给出的无需显式创建`Logger`、`Handler`、`Formatter`实例并接连注册的简化方法，其实内部有一个默认实例化过程以支持方便的`logging.xxxx`操作**？
**A：** 这就是`logging`模块的设计哲学：**提供简单快捷的接口，同时保留高度可定制的架构**。`logging.info()`等模块级别的快捷函数，实际上调用的是根`logger`的`info`方法，**如果没有配置过，会自动调用`basicConfig()`**。

**Q：** 那么为什么要这么设计，或者说为什么是`Formatter`->`Handler`->`Logger` --(包装)--> `LoggerAdapter`的注册顺序？
**A：** `Handler`只负责执行，它需要知道格式才能够格式化输出（过滤器同理），**相较于`Formatter`，`Handler`处于更高层**，所以`Formatter`可以独立于`Handler`，并可以被多个`Handler`共享。`Logger`是日志记录器，它在**内部不负责执行功能，所以需要至少一个`Handler`注册进来并把日志发送给它执行**，而适配器`LoggerAdapter`作为`Logger`的包装，需要将其作为一个参数，所以处于更高层。
所以当调用了`logger.info("message", extra={...})`时，实际的数据流向为：`LoggerAdapter.process()`添加额外上下文，然后由内部`Logger.log()`根据级别过滤日志，再对于日志记录器的每个`Handler`，通过`Handler.emit()`调用它对应的`Formatter`，最后经过`Formatter.format()`方法输出到`Handler`指定的目标（控制台、文件、网络）。它体现了一种模块解耦的编程思想。

### (2)`loguru`模块实现结构化日志
`loguru`原生支持结构化日志，其设计核心是`serialize`参数（在`logger.add()`时设置`serialize=True`）和`extra`字典（`loguru`基础部分有提及：通过`bind()`或`contextualize()`来添加上下文字段）。
```python
from loguru import logger  
import sys  

# 方法一：使用serialize参数
# 1. 配置一个sink，并启用序列化（输出JSON字符串）  
logger.remove() # 移除默认配置  
logger.add(  
    sys.stderr,  
    format="{message}",   # 格式只需消息本身，因为消息已经是JSON  
    serialize=True     # 核心参数：自动将日志记录字典序列化为JSON  
)  
  
# 2. 记录日志，通过extra参数添加上下文  
logger.info(  
    "User action completed",  
    extra={"user_id": "u12345", "action": "purchase", "item_count": 2}  
)

# 方法二：将额外参数添加进上下文，可以不用反复写输出额外参数语句
logger.remove()  
logger.add(sys.stderr, format="<level>{level}:</level> {message} {extra}")  
  
# 形式1：bind() 创建带有持久化上下文的子logger  
request_logger = logger.bind(request_id="req-xyz-111")  
request_logger.info("Request received") # 输出包含 request_id
request_logger.warning("Resource not found", extra={"path": "/api/users"}) # 同时包含request_id和path  
  
# 形式2：contextualize() 用于临时上下文（with语句或装饰器），基础部分有示例  
def process_order(order_id, user_id):  
    with logger.contextualize(order_id=order_id, user_id=user_id):  
        logger.info("Order processing started")  
        # 此处所有日志自动附带 order_id 和 user_id        logger.info("Inventory checked")  
    # with块外，上下文消失  
    logger.info("This log has no order context")  
  
process_order("order_456", "user_789")
```
### (3) 对比
`loguru`在结构化输出方面要比`logging`方便的多，甚至只需要一个参数就能够解决整个结构化输出问题，能够避免化太多精力在日志框架上。但是对于要求大量使用标准库的场景，来说理解`logging`原理和其结构化实现方式很重要。
## 2. Trace ID的生成与传递
Trace ID（追踪ID）是分布式系统中用于追踪单个请求在整个系统中的完整路径的唯一标识符。例如一个请求的声明周期，从其发出到服务端返回响应的过程中，无论执行服务的物理位置在哪里，无论执行到哪一步，都是同一个Trace ID贯穿始终。