# 总结
了解模块解耦思想后，在实现存储验证码的Redis访问时，发现其过程的解耦和在MySQL的处理中有很多相似，所以考虑到了构建一个数据库基类。但是仓储层`repository`模块中操作的数据库却有很多（关系数据库、向量数据库、Redis），难以定义一个最抽象的基类。
所以我对仓储层的专业架构进行了学习，从基础的按照数据库类型构建基类，到引入泛型，再到使用CQRS对动作抽象，以及企业中常用的CQRS结合数据库类型分层抽象的混合模式。最后理解了仓储层设计的参考准则，并对代码进行了优化。

# 学习过程
## 一、按数据库类型定义基类
**Q：** Redis数据库和MySQL这种关系数据库类型不同，但是它们却能够在模块解耦方面存在很多一致：在[[优化：25-12-31 模块解耦思想的学习过程&实现配置管理和代码分离]]中，我对MySQL访问数据库完成整个登录注册验证的流程进行了分离：
* 数据库配置项 => 配置层 `settings/config.py`
* 引擎创建、会话工厂、会话管理 => 核心代码 `core/database.py`
* 数据库CURD功能实现 => 仓储层 `repository/user_repo.py`
* 业务逻辑相关 => 路由层 `routers/auth_router.py`
【实际应该将上述的包含业务逻辑相关的路由层拆分为：协调多个仓库和业务逻辑的服务层，和处理HTTP请求，调用服务层完成业务逻辑的路由层】
而我设计Redis时同样也会把这套流程分别放到我配置MySQL的模块下，它们在企业应用的架构中处于同一个层级，那么**这是否代表可以定义不同种类型数据库统一到一个`BaseRepository`的抽象基类中**？
**A：** **技术上可以但是不应该**，因为它
* 违反了接口隔离原则：客户端被迫依赖它们不需要的方法
* 违反单一职责原则：一个类做太多事情
* 违法里氏替换原则：子类可能无法实现所有方法
* 降低了可读性：代码意图不清晰
更专业且简单的做法就是按照数据库类型进行分层抽象，关系数据库一类、向量数据库一类、Redis一类，基本架构为：
```python
# 定义三种类型的抽象基类，并定义抽象方法
class SQLBaseRepository(ABC):
class VectorBaseRepository(ABC):
class RedisBaseRepository(ABC):

# 然后分别实现用户数据、会话、验证码、知识库的存取
class UserRepository(SQLBaseRepository)
class SessionRepository(SQLBaseRepository)
class VerificationRepository(RedisBaseRepository)
class RAGRepository(VectorBaseRepository)
```
【重要】**但是需要注意不应该”过度设计“**。比如如果应用中只需要一个Redis数据库的访问仓库类和一个RAG向量数据库的访问仓库类，那么上面的`VectorBaseRepository`和`RedisBaseRepository`的抽象类就不需要，而只需要实现可能会有很多重复操作的关系数据库仓库类，一切设计从需求出发。
## 二、引入泛型
如果使用上面的抽象，以抽象基类`SQLBaseRepository`为例，它假设定义了CRUD四种操作方法的抽象函数，那么所有子类就要分别去实现这些方法，实现的仅是接口定义的复用。但是如果引入泛型，那么复用的就是接口定义+具体实现，只需子类继承后指定类型，就能够作为一个完整的仓储类去使用：
```python
# 定义类型变量
T = TypeVar('T', bound=Base)  # 限制T必须是ORM基类的子类
ID = TypeVar('ID', int, str)  # 限制ID类型

class GenericSQLRepository(Generic[T, ID]):
    """泛型SQL仓库 - 提供通用实现"""
    def __init__(self, session: AsyncSession, model: Type[T]):
        self.session = session
        self.model = model  # 关键：运行时知道具体模型类
    
    # 通用实现，所有SQL仓库共享
    async def get(self, id: ID) -> Optional[T]: ...
    async def create(self, data: dict) -> T: ...
    async def update(self, id: ID, data: dict) -> Optional[T]: ...

# 具体仓库创建
class ProductRepository(GenericSQLRepository[Product, int]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, Product)  # 一行代码获得所有CRUD功能
        
class UserRepository(GenericSQLRepository[User, int]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, User)  # 只需传入具体模型类
    
    # 可以添加用户特有方法
    async def get_by_email(self, email: str) -> Optional[User]: ...
```
这样只是在按数据库类型定义基类的方法上引入了类型变量，并未进行更多的抽象，且不影响子类功能的正常使用和定义，如果有特有方法也可以直接加入，实现了一层优化。
另外对于安全性问题：分层抽象的类型安全依靠子类实现，而泛型抽象编译时确保类型安全
## 三、CQRS模式与混合模式

CQRS是一种读写分离的架构模式，它**将修改状态的操作（命令）和读取状态的操作（查询）完全分离**。比如传统方法下，某个仓储类操作数据库会把CRUD的操作（读写混合）全部放在一个类中。但是CQRS则会分离出只处理修改的命令端，和只处理查询的查询端：
```python
# 传统CRUD：读写结合
class UserService:
	def get(self, id: int) -> User: ...
	def update(self, id: int, data: dict) -> User: ...

# CQRS：读写分离
class UserWriteService:  # 命令端：只处理修改
	def update(self, id: int, data: dict) -> User: ...
class UserReadService:   # 查询端：只处理读取
	def get(self, id: int) -> User: ... 
```
**Q：** 为什么要出现这种架构？它解决了什么问题？
**A：** 如果使用同一个数据模型来处理读写操作，那么随着系统的复杂度增加，在一些业务场景中，可能无法满足性能需求，比如某个新闻网站，每天仅发布（写）几十篇新闻，但是却有大量访问操作（读），这种读写负载不同的场景下，可以考虑读写分离，然后专注优化，比如对读操作实现高响应。另外读操作可能需要复杂的数据聚合，而写操作需要保证数据一致性等等。
至于分离后如何优化，则要结合业务场景考虑。比如读写用不同数据库、通过事件溯源（将状态变化记录为一系列事件，通过重放事件来重建状态，写模型存储事件，读模型通过订阅事件来更新）实现一致性。

但是CQRS需要将一个类拆成两个类使用，为了确保读写数据一致性还需要很多额外操作，适合的是大型企业的复杂业务（如电商订单系统）、写少读多的高并发系统（如新闻网站）。**对于简单业务，纯CQRS可能会引发过多的复杂性，所以现实中常常使用混合模式：将CQRS与其他模式结合，在需要的地方使用CQRS，在其他地方使用传统CRUD**。

【重要】所以对于仓储层的架构设计，假设对于某电商系统的后端，可以遵循这样的流程：
* 开始只有三四个实体时，可以保持原样，即使存在代码的重复但也能接受。
* 当实体增多时，可以考虑根据数据库类型创建抽象基类，并引入泛型，使得实体的创建可以简化。
* 当访问量太高，为了实现某些功能的高并发高相应，可以对某个业务逻辑相关的实体进行优化，从原来的仓储抽象基类+泛型继承，转换到CQRS模式，将负责写入的命令端维持原样，而将负责读的查询端使用Redis缓存。但需要通过事件回溯等机制来确保读写数据的一致性。
* 这样整个后端架构就是混合模式：简单业务逻辑对应的简单实体使用传统的CRUD，对需要支持高响应高并发的复杂实体使用CQRS模式。
**但是和抽象基类的设计一样：实际需求大于架构一致性。只需要在遇到问题时再引入复杂方案**。