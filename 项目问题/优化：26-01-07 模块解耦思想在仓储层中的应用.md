# 总结
了解模块解耦思想后，在实现存储验证码的Redis访问时，发现其过程的解耦和在MySQL的处理中有很多相似，所以考虑到了构建一个数据库基类。但是仓储层`repository`模块中操作的数据库却有很多（关系数据库、向量数据库、Redis），难以定义一个最抽象的基类。
所以我对仓储层的专业架构进行了学习，从基础的按照数据库类型构建基类，到引入泛型，再到使用CQRS对动作抽象，以及企业中常用的CQRS结合数据库类型分层抽象的混合模式。最后尝试对仓储层的实现进行了企业级的优化。

# 学习过程
## 一、按数据库类型定义基类
**Q：** Redis数据库和MySQL这种关系数据库类型不同，但是它们却能够在模块解耦方面存在很多一致：在[[优化：25-12-31 模块解耦思想的学习过程]]中，我对MySQL访问数据库完成整个登录注册验证的流程进行了分离：
* 数据库配置项 => 配置层 `settings/config.py`
* 引擎创建、会话工厂、会话管理 => 核心代码 `core/database.py`
* 数据库CURD功能实现 => 仓储层 `repository/user_repo.py`
* 业务逻辑相关 => 路由层 `routers/auth_router.py`
【实际应该将上述的包含业务逻辑相关的路由层拆分为：协调多个仓库和业务逻辑的服务层，和处理HTTP请求，调用服务层完成业务逻辑的路由层】
而我设计Redis时同样也会把这套流程分别放到我配置MySQL的模块下，它们在企业应用的架构中处于同一个层级，那么**这是否代表可以定义不同种类型数据库统一到一个`BaseRepository`的抽象基类中**？
**A：** **技术上可以但是不应该**，因为它
* 违反了接口隔离原则：客户端被迫依赖它们不需要的方法
* 违反单一职责原则：一个类做太多事情
* 违法里氏替换原则：子类可能无法实现所有方法
* 降低了可读性：代码意图不清晰
更专业且简单的做法就是按照数据库类型进行分层抽象，关系数据库一类、向量数据库一类、Redis一类，基本架构为：
```python
# 定义三种类型的抽象基类，并定义抽象方法
class SQLBaseRepository(ABC):
class VectorBaseRepository(ABC):
class RedisBaseRepository(ABC):

# 然后分别实现用户数据、会话、验证码、知识库的存取
class UserRepository(SQLBaseRepository)
class SessionRepository(SQLBaseRepository)
class VerificationRepository(RedisBaseRepository)
class RAGRepository(VectorBaseRepository)
```
【重要】**但是需要注意不应该”过度设计“**。比如如果应用中只需要一个Redis数据库的访问仓库类和一个RAG向量数据库的访问仓库类，那么上面的`VectorBaseRepository`和`RedisBaseRepository`的抽象类就不需要，而只需要实现可能会有很多重复操作的关系数据库仓库类，一切设计从需求出发。
## 二、引入泛型
如果使用上面的抽象，以抽象基类`SQLBaseRepository`为例，它假设定义了CRUD四种操作方法的抽象函数，那么所有子类就要分别去实现这些方法，实现的仅是接口定义的复用。但是如果引入泛型，那么复用的就是接口定义+具体实现，只需子类继承后指定类型，就能够作为一个完整的仓储类去使用：
```python
# 定义类型变量
T = TypeVar('T', bound=Base)  # 限制T必须是ORM基类的子类
ID = TypeVar('ID', int, str)  # 限制ID类型

class GenericSQLRepository(Generic[T, ID]):
    """泛型SQL仓库 - 提供通用实现"""
    def __init__(self, session: AsyncSession, model: Type[T]):
        self.session = session
        self.model = model  # 关键：运行时知道具体模型类
    
    # 通用实现，所有SQL仓库共享
    async def get(self, id: ID) -> Optional[T]: ...
    async def create(self, data: dict) -> T: ...
    async def update(self, id: ID, data: dict) -> Optional[T]: ...

# 具体仓库创建
class ProductRepository(GenericSQLRepository[Product, int]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, Product)  # 一行代码获得所有CRUD功能
        
class UserRepository(GenericSQLRepository[User, int]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, User)  # 只需传入具体模型类
    
    # 可以添加用户特有方法
    async def get_by_email(self, email: str) -> Optional[User]: ...
```
这样只是在按数据库类型定义基类的方法上引入了类型变量，并未进行更多的抽象，且不影响子类功能的正常使用和定义，如果有特有方法也可以直接加入，实现了一层优化。
另外对于安全性问题：分层抽象的类型安全依靠子类实现，而泛型抽象编译时确保类型安全
## 三、CQRS模式与混合模式

