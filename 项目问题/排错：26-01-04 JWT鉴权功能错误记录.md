### 总结
在实现跟做项目的鉴权功能时，由于示例代码的简化导致我在跟做时出错，为了排查错误学习了不太熟悉的JWT鉴权知识，看懂了示例代码并解决了问题。但在学习过程中意识到双Token方案是一种经典的基础安全措施，于是深入原理地学习了其他进阶的安全措施。

### 解决过程
#### 一、问题概述
在实现项目鉴权功能时，由于对此方面不是太熟所以只是照视频打，但是在之后测试登录功能时始终出现403错误。但我缺少相关知识，看不懂这些代码，只能做最基础的认识：
```python
"""  
登录成功后，根据用户id创建一个JWToken返回给用户，后期用户访问一些需要登录的接口时
再把这个JWToken放到请求头中，来实现身份验证。  
"""  
from datetime import datetime  
from http.server import BaseHTTPRequestHandler  
  
import jwt  
from fastapi import Security, HTTPException  
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer  
from enum import Enum  
from settings import settings  
from starlette.status import HTTP_401_UNAUTHORIZED, HTTP_403_FORBIDDEN  
  
from threading import Lock  
  
  
class SingletonMeta(type):  
    """  This is a thread-safe implementation of Singleton.    """    
    _instances = {}  
    _lock = Lock()  
  
    def __call__(cls, *args, **kwargs):  
        with cls._lock:  
            if cls not in cls._instances:  
                instance = super().__call__(*args, **kwargs)  
                cls._instances[cls] = instance  
        return cls._instances[cls]  
  
  
class TokenTypeEum(Enum):  
    ACCESS_TOKEN = 1  
    REFRESH_TOKEN = 2  
  
  
# SingletonMeta表示使用单例模式设计  
class AuthHandler(metaclass=SingletonMeta):  
    security = HTTPBearer()  
    # Authorization: Bearer {token}  
  
    secret = settings.jwt_secret_key  
  
    def _encode_token(self, user_id: int, typ: TokenTypeEum):  
        payload = dict(  
            iss=user_id,  
            sub=int(typ.value),  
        )  
        to_encode = payload.copy()  
        if typ == TokenTypeEum.ACCESS_TOKEN:  
            exp = datetime.now() + settings.jwt_access_token_expires  
        else:  
            exp = datetime.now() + settings.jwt_refresh_token_expires  
        to_encode.update({"exp": int(exp.timestamp())})  
        return jwt.encode(to_encode, self.secret, algorithm='HS256')  
  
    def encode_login_token(self, user_id: int):  
        access_token = self._encode_token(user_id, TokenTypeEum.ACCESS_TOKEN)  
        refresh_token = self._encode_token(user_id, TokenTypeEum.REFRESH_TOKEN)  
        login_token = dict(  
            access_token=f"{access_token}",  
            refresh_token=f"{refresh_token}",  
        )  
        return login_token  
  
    def encode_update_token(self, user_id):  
        access_token = self._encode_token(user_id, TokenTypeEum.ACCESS_TOKEN)  
  
        update_token = dict(  
            access_token=f"{access_token}",  
        )  
        return update_token  
  
    def decode_access_token(self, token):  
        # ACCESS TOKEN：不可用（过期，或有问题），都用403错误  
        try:  
            payload = jwt.decode(token, self.secret, algorithms=['HS256'])  
            if payload["sub"] != int(TokenTypeEum.ACCESS_TOKEN.value):  
                raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Token类型错误！")  
            return payload["iss"]  
        except jwt.ExpiredSignatureError:  
            raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Access Token已过期！")  
        except jwt.InvalidTokenError as e:  
            raise HTTPException(status_code=HTTP_403_FORBIDDEN, detail="Access Token不可用！")  
  
    def decode_refresh_token(self, token):  
        # REFRESH TOKEN：不可用（过期，或有问题），都用401错误  
        try:  
            payload = jwt.decode(token, self.secret, algorithms=['HS256'])  
            if payload['sub'] != int(TokenTypeEum.REFRESH_TOKEN.value):  
                raise HTTPException(  
                    status_code=HTTP_401_UNAUTHORIZED,  
                    detail="Token类型错误！"  
                )  
            return payload["iss"]  
        except jwt.ExpiredSignatureError:  
            raise HTTPException(  
                status_code=HTTP_401_UNAUTHORIZED,  
                detail="Refresh Token已过期！"  
            )  
        except jwt.InvalidTokenError as e:  
            raise HTTPException(  
                status_code=HTTP_401_UNAUTHORIZED,  
                detail="Refresh Token不可用！"  
            )  
  
    def auth_access_dependency(self, auth: HTTPAuthorizationCredentials = Security(security)):  
        # 校验access_token是否合法的依赖项  
        return self.decode_access_token(auth.credentials)  
  
    def auth_refresh_dependency(self, auth: HTTPAuthorizationCredentials = Security(security)):  
        # 校验refresh_token是否合法的依赖项  
        return self.decode_refresh_token(auth.credentials)
```
整个`AuthHandler`类中有7个方法：
* `_encode_token`用于根据用户id和令牌类型（短期还是长期）生成Token；
* `encode_login_token`调用两次前一个函数，分别生成两种Token；
因为这个鉴权采用的是短期令牌`ACCESS_TOKEN`和长期令牌`REFRESH_TOKEN`的双令牌机制，所以存在对两种Token的解码：
* `decode_access_token`对`ACCESS_TOKEN`解码
* `decode_refresh_token`对`REFRESH_TOKEN`解码
因为双令牌机制是当短期令牌过期就通过长期令牌获取新的短期令牌，所以存在对短期令牌刷新的方法：
* `encode_update_token`用于生成新的短期令牌
以上类`AuthHandler`的功能基本实现完毕，但为了实现验证逻辑与业务逻辑分离，所以提供了两种令牌依赖注入时所需的两个依赖项：
* `auth_access_dependency`是校验access_token是否合法的依赖项
* `auth_refresh_dependency`校验refresh_token是否合法的依赖项
这是发生问题时对鉴权这部分功能的全部理解，所以开始了JWT的学习：[[JWT]]

#### 二、根源发现
在了解基本知识后，再来解决代码中的错误时发现存在三个不规范：加密密钥`jwt_secret_key`太短、时间设置并未使用UTC标准时间不够规范、以及载荷payload中的`sub`字段不是字符串类型。
* `jwt_secret_key`太短，是我在`Settings`类的配置中只设置了19位字符串作为密钥，但是我的编码方式`HS256`需要至少32字节的字符串来辅助编码，但是修改后仍没有任何改变。
* 对于时间问题，我尝试将`_encode_token`中的时间改为`datetime.utcnow()`实现了规范，但是实现规范的前后，我都通过解密辅助工具能够成功获取我的令牌的过期时间是2月4号，显然不是时间规范问题。
* 对于字段类型，借助AI编写的验证脚本，猜想得到了验证：
```python
# 临时脚本：创建新密钥并测试
import secrets
import base64
import jwt
from datetime import datetime, timedelta

# 生成新密钥
new_secret = base64.b64encode(secrets.token_bytes(32)).decode()
print(f"新密钥: {new_secret}")

# 使用新密钥生成令牌
payload = {
    "iss": 4,
    "sub": 1,  # ACCESS_TOKEN
    "exp": int((datetime.now() + timedelta(days=15)).timestamp())
}

new_token = jwt.encode(payload, new_secret, algorithm='HS256')
print(f"新令牌: {new_token}")

# 测试解码
try:
    decoded = jwt.decode(new_token, new_secret, algorithms=['HS256'])
    print(f"解码成功: {decoded}")
except Exception as e:
    print(f"解码失败: {e}")
```
返回结果是`解码失败: Subject must be a string`，这里的脚本几乎还原了我在编码解码Token时的数据类型，所以问题就出在payload的`sub`字段，在示例代码中明确指明了`sub`字段的类型应为字符串，而既然脚本中解析失败，那么我在解码时出错位置应该也是在执行`jwt.decode()`部分。

### 三、问题解决
通过将原先的枚举类`TokenTypeEum`中两个字段的类型从整型改为字符串，并修改了相关的判断逻辑，让包括鉴权的登录操作成功执行了。
```python
class TokenTypeEnum(Enum):  
    ACCESS_TOKEN = "access_token"  
    REFRESH_TOKEN = "refresh_token"  
  
  
class AuthHandler(metaclass=SingletonMeta):  
    security = HTTPBearer()  
  
    def __init__(self):  # 略
  
    def _encode_token(self, user_id: int, token_type: TokenTypeEnum):  
        """生成 JWT Token"""        
        now = datetime.utcnow()  # 规范的时间设置
  
        if token_type == TokenTypeEnum.ACCESS_TOKEN:  
            expires_delta = settings.jwt_access_token_expires  
        else:  
            expires_delta = settings.jwt_refresh_token_expires  
  
        expire = now + expires_delta  
		
		# 修改部分
        payload = {  
            "iss": str(user_id),  # 用户ID转为字符串  
            "sub": token_type.value,  # 使用枚举值（字符串）  
            "iat": int(now.timestamp()),  # 签发时间  
            "exp": int(expire.timestamp()),  # 过期时间  
        }  
  
        return jwt.encode(  
            payload,  
            self.secret,  
            algorithm=self.algorithm  
        )  
        
    def decode_access_token(self, token: str):  
        """解码并验证 Access Token"""        
        try:  
            payload = jwt.decode(  
                token,  
                self.secret,  
                algorithms=[self.algorithm],  
                options={"require": ["exp", "iat", "iss", "sub"]}  
            )  
  
            # 验证 Token 类型  
            if payload.get("sub") != TokenTypeEnum.ACCESS_TOKEN.value:  
                raise HTTPException(  
                    status_code=HTTP_403_FORBIDDEN,  
                    detail="Invalid token type: not an access token"  
                )  
  
            # 返回用户 ID            
            try:  
                user_id = int(payload.get("iss", 0))  
                if user_id <= 0:  
                    raise HTTPException(  
                        status_code=HTTP_403_FORBIDDEN,  
                        detail="Invalid user ID"  
                    )  
                return user_id  
            except (ValueError, TypeError):  
                raise HTTPException(  
                    status_code=HTTP_403_FORBIDDEN,  
                    detail="Invalid user ID format"  
                )  
  
        except jwt.ExpiredSignatureError:  
            raise HTTPException(  
                status_code=HTTP_403_FORBIDDEN,  
                detail="Access token has expired"  
            )  
        except jwt.InvalidTokenError as e:  
            raise HTTPException(  
                status_code=HTTP_403_FORBIDDEN,  
                detail=f"Invalid access token: {str(e)}"  
            )  
  
    def encode_login_token(self, user_id: int):  # 略
  
    def encode_update_token(self, user_id: int):  # 略
  
  
    def decode_refresh_token(self, token: str):  # 略
  
    def auth_access_dependency(self, auth: HTTPAuthorizationCredentials = Depends(security)):  # 略
  
    def auth_refresh_dependency(self, auth: HTTPAuthorizationCredentials = Depends(security)):  # 略
```

