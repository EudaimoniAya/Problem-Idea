#### 总结
以优化硬编码的安全隐患为由，学习了`pydantic-settings`的配置管理类，并从中学习到了配置分层的代码管理思想。在后续实践中将学习到的类内属性按逻辑管理思想，引申为对整个项目的代码按逻辑拆分重构，并按照此思想对示例项目尝试进行了企业级的代码管理优化。

#### 学习过程
##### 第一部分：解决硬编码引入配置管理类
在配置数据库时因为一直使用硬编码，将`DB_URI`变量存进`settings.py`中。考虑到安全性和专业性于是让AI帮忙优化，它给出了一大段使用了`pydantic-settings`中的`BaseSettings`类的代码，其中包含层层的继承：
```python
# 安全管理配置信息，隐私数据存放在.env文件中 位置：settings/config.py
class DatabaseSettings(BaseSettings):  
    """数据库相关配置组（未来可以独立扩展）"""  
  
    # --- 主数据库（MySQL，用于用户、核心业务） ---    
    main_db_host: str = Field("localhost")  
    main_db_port: int = Field(3306)  
    main_db_user: str = Field("root")  
    main_db_password: str = Field(...)  
    main_db_name: str = Field("ainame")  
  
    @property  
    def main_database_url(self) -> str:  
        """动态构建MySQL异步连接字符串，未配置则返回None"""  
        return (f"mysql+aiomysql://{self.main_db_user}:{self.main_db_password}@"  
                f"{self.main_db_host}:{self.main_db_port}/{self.main_db_name}?"  
                f"charset=utf8mb4")  
  
    # --- 会话数据库（PostgreSQL，未来预留） --- 
    # 略   
  
  
class Settings(DatabaseSettings):  
    """应用主配置类，继承数据库配置"""  
    # --- 应用基础配置 ---    
    # ...
  
    # --- 安全配置，关乎应用安全，是生产环境必备项 ---  
    # ...  

    # --- AI 服务配置 （未来可以独立出来一个组件并让Settings继承）---  
    # ...

    # --- Pydantic V2 配置（无需深入理解）---  
    model_config = {  
        # 使用 Path(__file__).parent.parent 来定位项目根目录  
        "env_file": Path(__file__).parent.parent / ".env",  
        "env_file_encoding": "utf-8",  
    }
```
**学习：**`BaseSettings`作为`pydantic-settings`的核心类，是能够替代`os.getenv`和手工解析配置文件的强大工具，能够让配置管理变得更安全、声明式和强大。继承了`BaseSettings`的子类，其内部的所有类属性名均可用小写下划线命名（蛇形命名），Pydantic框架将会自动将其转换成大写下划线的环境变量形式，并通过`model_config`的`env_file`找到对应的`.env`文件，读取类属性名大写后对应的环境变量，再搭配`Field`是否设置默认值可以实现字段的可选必填。

**Q：** 为什么要让`DatabaseSettings`继承了`BaseSettings`类后，再让`Settings`继承`DatabaseSettings`呢？
**A：** 这是一种模块化设计思想的实现，**理论上当然可以把这些配置项全部放在一起**，作为`BaseSettings`一个子类的类属性。但是企业级项目的配置项会很多，**为了管控需求，可以利用继承将扩展足够大的配置信息分离出去作为一个模块**，如上面的数据库配置项部分`DatabaseSettings`，继承了它的`Settings`在实例化后能获取它的所有信息，所以未来在“总部”`Settings`的配置多了，比如大模型调用会用很多家厂商的API_KEY和BASE_URL，之后就可以把那部分独立出去，作为`AIServerSettings`模块，并让`Settings`继承，将功能注册进其中。

##### 第二部分：自行设计邮件发送配置
```python
class MailSettings(BaseSettings):  
    qq_mail_username: str = Field(...)  
    qq_mail_password: str = Field(...)  
    qq_mail_from: str = Field(...)  
    qq_mail_port: int = Field(587)  
    qq_mail_server: str = Field("smtp.qq.com")  
    qq_mail_from_name: str = Field("AIName项目测试")  
    qq_mail_starttls: bool = Field(True)  
    qq_mail_ssl_tls: bool = Field(False)
    
class Settings(DatabaseSettings, MailSettings):
	# 略
```
这一部分再次对跟做项目的硬编码模式进行了优化，但是在后续使用中发现了不妥：
**Q：** 为什么像`qq_mail_username`、`qq_mail_password`这种“应用层”的参数，会和底层的`qq_mail_ssl_tls`这类"配置层"的参数混合？**既然配置项的实例要尽量保证单例，避免不必要的资源浪费，那就不应该让“应用层”和“配置层”的参数混合。** 因为在`settings/__init__.py`中，使用装饰器`@lru_cache`获取`Settings`实例，它通过将创建的实例保存起来，等后续使用相同参数调用时直接返回缓存结果，避免重复加载环境变量，由此实现单例。很明显从逻辑上就不该把业务相关的数据放进启动时加载的配置中。
**A：** 之后的设计中，进行了严格的逻辑划分。在此配置中移除了"应用层"的参数，仅保留了底层的"配置层"属性，**判断依据就是这些值在项目部署到服务器时是否固定？若固定则属于配置数据，若仍然可变则是业务数据。**

##### 第三部分：业务逻辑的分离尝试
在跟练项目中，示例代码将创建数据库引擎、会话工厂、会话管理工具的功能，连同ORM模型的`Base`类，一同存放进`models/__init__.py`中。但是类似之前的配置管理类，数据库引擎、会话工厂、会话管理工具这些也是需要尽量保证少创建实例以节省资源，它们就对应了更为底层的一些功能，而用于数据库交互的ORM模型和与外界交互的Pydantic模型Schema则是请求层面作用于两个不同方向的数据模型类。此外`__init__.py`在导入时就执行内部代码，也许那并不是一个创建底层单例的好时机。
所以其实本质它们三个（数据库引擎、会话工厂、会话管理工具）、ORM模型、Pydantic模型，除了两个数据模型大多数情况需要共用一些同名属性用于规范输出之外，并没有太大的直接关系，它们是通过处理HTTP请求的逻辑函数组合到一起的：HTTP请求发送到后，逻辑函数通过单例的底层会话工厂&管理工具，声明式地注入了所需的会话依赖项，然后内部逻辑通过会话操作ORM模型与数据库交互，最后返回结果时通过路由函数装饰器的参数`response_model`指定响应的Pydantic数据模型。
**它们的关系就像是三张直接关联性没那么强的数据表，通过了一个中间表（视图函数）将三个表关联起来。** 所以针对视频项目中的位置分配进行了优化：将数据库引擎、会话工厂、会话管理工具的创建，放在`core/database.py`文件中，将依赖项放入`dependencies.py`中，将ORM模型类放入`models/`中，其中`Base`基类放入`models/__init__.py`，并在文件最后暴露models中所有的ORM模型类完成注册，便于后续模型迁移。将Pydantic模型类放入`schemas/`中。以下是目前项目结构：
```
AINameProject/
├── alembic
│   ├── versions
│   │   └── f0bf8046caf3_add_user_email_code_model.py
│   ├── env.py
│   ├── README
│   └── script.py.mako
├── core
│   ├── __init__.py
│   ├── database.py
│   └── mail.py
├── models
│   ├── __init__.py
│   └── User.py
├── repository
│   ├── __init__.py
│   └── user_repo.py
├── routers
│   ├── __init__.py
│   └── auth_router.py
├── schemas
│   ├── __init__.py
│   └── user_schema.py
├── settings
│   ├── __init__.py
│   └── config.py
├── .env
├── .env.example
├── alembic.ini
├── dependencies.py
├── main.py
├── Readme.md
├── scr_test_db.py
├── scr_tree.py
└── test_main.http
```