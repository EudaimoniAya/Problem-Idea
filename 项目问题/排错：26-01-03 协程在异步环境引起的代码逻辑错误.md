#### 总结
因为同步调用了一个返回布尔值的异步函数，且PyCharm没有发出警告，导致返回的是一个协程对象，让之后基于它的逻辑判断全部失效，掩盖了查询操作存在的漏洞。

#### 解决过程
在实现后端测试项目中的注册功能时，使用了将邮箱及验证码存入关系数据库的原始方法。在跟做时遇到了服务器的RuntimeWarning警告，表示我在依赖注入时，`get_session`依赖项返回了一个异步生成器，且在逻辑函数中使用了`await`来等待一个异步函数`check_email_code`，但是在调用该函数时没有使用await。
```python
# 负责校验验证码 位置：routers/auth_router.py  
email_code_repo = EmailCodeRepository(session=session)  
email_code_match = email_code_repo.check_email_code(    # 添加await
	email=str(data.email), 
	code=str(data.code)
	)
if not email_code_match:  
    raise HTTPException(400, detail="邮箱或验证码错误！")  
    
	
# 依赖项get_session 位置：dependencies.py
async def get_session() -> AsyncSession:  
    session = AsyncScopedSession()  
    try:  
        yield session  
        # await session.commit()  
    except Exception:  
        session.rollback()    # 添加await  
        raise  
    finally:  
        await session.close()  
        AsyncScopedSession.remove()
```
在解决完调用该异步函数，以及依赖项`get_session`中回滚操作`session.rollback()`未添加的`await`后，原来能够执行的代码逻辑：通过HTTP的POST请求，传入用户登录所需的信息（用户名、密码、密码确认、邮箱、验证码），逻辑函数接受到数据执行查找邮箱是否注册、验证码是否正确/过期等逻辑后，将用户添加进数据库，返回表示成功的HTTP响应报文。
于是通过日志排查，限定了错误区间在验证码校验部分：

```python
async def check_email_code(self, email: str, code: str) -> bool:  
    async with self.session.begin():  
        stmt = select(EmailCode).where(EmailCode.email == email)  
		# 修改为：# stmt = select(EmailCode).where(EmailCode.email == email, EmailCode.code == code)  
		email_code: EmailCode | None = await self.session.scalar(stmt)
        if email_code is None:  
            print("email_code不存在")  
            return False  
        if datetime.now() > email_code.expires_time:  
            print("验证码过期")  
            return False  
        return True
```
它希望通过`email_code`接收数据库的一条(邮箱, 验证码)数据，但是日志返回的验证码过期时间却与符合业务逻辑的记录不一致。因为并未开发相关功能，不能实现验证码到期删除，所以会出现一个邮箱对应多条验证码的情况，而`scalar()`返回的又是符合条件的最上面的一条数据。所以以上的代码是默认了一个邮箱一个验证码情况的，要在这种情况做出最简单的修改就是邮箱和验证码一起查，就一定能得到正确的记录。
【但是这种处理并不合理，在高并发场景下并不应该把这类消息存进数据库，而应该使用Redis存进服务器内存。或者简单一点，在需要这种有风险的调用时，通过mypy规范接收的对象类型，此时函数定义的类型标注没用，因为协程对象的返回是高于函数返回值本身的】

至此问题解决了，但是为什么在没有加那两处await前代码能够正常执行，而绕过我原本有错的验证码查询呢？**因为调用异步（协程）函数会创建一个协程对象，函数内部代码不会执行。如果不用`await`，那么将会得到一个非空的协程对象，它在布尔上下文中一定为True，所以即使异步函数返回的结果应该是False，整个协程对象也是作为True存在的。**
所以在给`routers/auth_router.py`中的代码添加`await`后，逻辑正常执行，`email_code`得到正确的结果`False`，导致抛出HTTP异常。依赖项执行时捕捉到了错误开始回滚，这让我一直都忘了加`await`的`session.rollback()`第一次执行并返回警告。

#### 相关知识

Python中协程需要在事件循环下才能正确执行，在Python 3.6及以前，需要显示地获取和运行事件循环：
```python
async def main():
    await asyncio.sleep(1)
    print("Hello")

loop = asyncio.get_event_loop()
loop.run_until_complete(main())  # 显式运行
```
在Python 3.7版本后，可使用`asyncio.run()`方法自动创建、运行、关闭事件循环：
```python
asyncio.run(main())
```
##### 关于`await`
`await`不会自动创建事件循环，但是必须在事件循环中运行。当使用`asyncio.run()`时，该函数会创建一个新的事件循环，并运行传入的协程（通常是主协程），在这个主协程中，可以使用`await`来等待其他协程。
具体来说，如果用`async def`定义一个协程函数，调用这个函数会返回一个协程对象，但并不会执行它。要执行协程，有以下几种方式：
1. 在另一个协程中使用await来等待它。
2. 使用`asyncio.run()`来运行一个协程（这是Python 3.7+推荐的方式，它会创建事件循环，运行协程，然后关闭循环）。
3. 使用`asyncio.create_task()`来将协程包装成任务，并在事件循环中调度（这需要在事件循环中运行）。

##### 【重要】梳理：从进程到线程、再到Python协程和异步编程
原先在OS内进程是获得资源和执行任务的最小单位，但是因为其并发程度仍然不足，比如有两个进程A和B，它们都是一个庞大的任务，里面存在很多I/O操作，所以如果A或者B执行到了这些I/O操作，那就会直接阻塞并执行其他进程。但是如果进程只有这两个时，CPU就又空闲下来了。
所以出现了能够将进程的任务细化的线程，比如那两个进程A和B，线程把它们再次分解成更细化的子任务，最终I/O操作可能就只存在于某几个线程中，可执行的线程变得更多，调度起来也更加地方便，更何况同一进程内的不同线程调度起来资源消耗量极低，于是线程变成了执行任务的最小单位，进程是获得资源的最小单位。
**对于Python，它内部因为全局解释器锁（Global Interpreter Lock, GIL），导致其虽然能够创建多个OS线程（Python的线程直接映射到OS线程），但同一时刻只允许一个线程执行Python字节码：当一个Python线程被OS调度并开始执行时，它必须先获取解释器内部的GIL才能执行，所以即使OS层面这些线程一直在被并行调度，它们仍然不能同时执行Python代码**。
所以出现了两种解决方案：一个是使用多进程编程，绕过GIL锁，从而OS层面看到的是多个独立的Python进程，每个进程有自己的GIL和内存空间，可以真正并行执行（一个Python进程同一时刻只有一个线程在执行Python字节码）。另一个是让单个线程在用户空间内再次细分，即微线程（协程）。**所以Python并发架构的三种方式分别为：受GIL限制的多线程、绕过GIL限制的多进程、在单线程内细分的协程**。
在计算机中分为用户级线程和内核级线程，用户级线程是在用户空间内的任务/代码调度，OS是不知道的。在《操作系统》的用户级线程简单示例中，通过将一段函数手动分片执行实现用户级线程，在`asyncio`生态成熟之前，确实存在着”先有用户级线程，再在其上实现细分的协程“这种严格分层架构。但是在现代Python中可以直接编写协程，而不必直接依赖用户级线程，如今的Python异步编程就来自协程这个概念。
现在异步编程的核心是”事件循环+协程“，事件循环就像场地魔法一样，所有协程必须在里面才能够正确执行。`asyncio.run()`能够创建事件循环，运行协程，然后关闭循环。`async def`能够定义协程函数，返回一个协程对象，这个协程对象可以被看作是一个可等待的对象（Awaitable），只有在事件循环中才能够正确返回结果。**`await`作为让出控制权的标记，核心是”合作式“让出：它会挂起当前协程，将控制权交还给事件循环，协程就被放在了事件循环之中等待执行了**。
