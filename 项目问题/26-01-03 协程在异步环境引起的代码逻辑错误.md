##### 结论
因为同步调用了一个返回布尔值的异步函数，且PyCharm没有发出警告，导致返回的是一个协程对象，让之后基于它的逻辑判断全部失效，掩盖了查询操作存在的漏洞。

##### 解决过程
在实现后端测试项目中的注册功能时，使用了将邮箱及验证码存入关系数据库的原始方法。在跟做时遇到了服务器的RuntimeWarning警告，表示我在依赖注入时，`get_session`依赖项返回了一个异步生成器，且在逻辑函数中使用了`await`来等待一个异步函数`check_email_code`，但是在调用该函数时没有使用await。
```python
# 负责校验验证码 位置：routers/auth_router.py  
email_code_repo = EmailCodeRepository(session=session)  
email_code_match = email_code_repo.check_email_code(    # 添加await
	email=str(data.email), 
	code=str(data.code)
	)
if not email_code_match:  
    raise HTTPException(400, detail="邮箱或验证码错误！")  
    
	
# 依赖项get_session 位置：dependencies.py
async def get_session() -> AsyncSession:  
    session = AsyncScopedSession()  
    try:  
        yield session  
        # await session.commit()  
    except Exception:  
        session.rollback()    # 添加await  
        raise  
    finally:  
        await session.close()  
        AsyncScopedSession.remove()
```
在解决完调用该异步函数，以及依赖项`get_session`中回滚操作`session.rollback()`未添加的await后，原来能够执行的代码逻辑：通过HTTP的POST请求，传入用户登录所需的信息（用户名、密码、密码确认、邮箱、验证码），逻辑函数接受到数据执行查找邮箱是否注册、验证码是否正确/过期等逻辑后，将用户添加进数据库，返回表示成功的HTTP响应报文。
于是通过日志排查，限定了错误区间在验证码校验部分：

```python
async def check_email_code(self, email: str, code: str) -> bool:  
    async with self.session.begin():  
        stmt = select(EmailCode).where(EmailCode.email == email)  
		# 修改为：# stmt = select(EmailCode).where(EmailCode.email == email, EmailCode.code == code)  
		email_code: EmailCode | None = await self.session.scalar(stmt)
        if email_code is None:  
            print("email_code不存在")  
            return False  
        if datetime.now() > email_code.expires_time:  
            print("验证码过期")  
            return False  
        return True
```
它希望通过`email_code`接收数据库的一条(邮箱, 验证码)数据，但是日志返回的验证码过期时间却与符合业务逻辑的记录不一致。因为并未开发相关功能，不能实现验证码到期删除，所以会出现一个邮箱对应多条验证码的情况，而`scalar()`返回的又是符合条件的最上面的一条数据。所以以上的代码是默认了一个邮箱一个验证码情况的，要在这种情况做出最简单的修改就是邮箱和验证码一起查，就一定能得到正确的记录。
【但是这种处理并不合理，在高并发场景下并不应该把这类消息存进数据库，而应该使用Redis存进服务器内存。或者简单一点，在需要这种有风险的调用时，通过mypy规范接收的对象类型，此时函数定义的类型标注没用，因为协程对象的返回是高于函数返回值本身的】

至此问题解决了，但是为什么在没有加那两处await前代码能够正常执行，而绕过我原本有错的验证码查询呢？**因为调用异步函数时如果不用await，那么将会得到一个绝对非空的协程对象，它在布尔上下文中一定为True，所以即使异步函数返回的结果应该是False，整个协程对象也是作为True存在的。**
所以在给`routers/auth_router.py`中的代码添加await后，逻辑正常执行，`email_code`得到正确的结果False，导致抛出HTTP异常。依赖项执行时捕捉到了错误开始回滚，这让我一直都忘了加await的`session.rollback()`第一次执行并返回警告。