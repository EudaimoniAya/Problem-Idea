### 总结
在设计项目初始目录时，遇到了应该如何把AI功能融入到传统后端项目中的问题，此前学习的模块解耦思想和实践都是局限于单个领域的：它能够专业地把传统后端项目和AI应用项目架构分层，但是在设计过程中意识到过分解构则容易生搬硬套地将AI应用项目强行映射到传统后端项目中，让原本高内聚的AI部分按照错误的逻辑分离，增加了协作难度且不易于维护。
所以为了最大程度上保留AI部分的内聚，引入了二维架构设计的思想：将AI应用作为一个大型的垂直领域模块接入，并通过模块解耦思想，将AI模块与主应用相同的模块（如配置管理、日志记录等）提取出来在主应用内统一配置。AI模块在主应用的`core`模块集成，并在服务层与主应用平等地提供服务，于主应用的路由层汇聚。
中间解决了一些设计问题，比如：AI与传统后端依赖的模型层不同，应该如何设计？AI是否应该直接操作数据库？如果不能的话，应该由谁负责，如何负责？

### 学习过程
#### 一、传统后端项目和AI应用项目的分层
一种典型的简易后端项目的架构为：
* 运维：日志与监控、配置管理等，  
* 模型层：包含两种数据模型，用于操作数据库的ORM模型（models）和数据验证的Pydantic模型（schemas）    
  但是两种模型因为作用位置不同，物理上不会放在一起，ORM模型单独作为`models`模块内容，Pydantic模型作为`schemas`模块下内容。  
* 核心层：包含像数据库引擎创建、会话工厂创建等基础设施代码  
* 仓储层：根据业务需求操作数据库  
* 服务层：实现业务需求，向路由层提供服务  
* 路由层：调用服务层功能，完成HTTP请求、响应报文处理，暴露端口提供服务
而一个智能体驱动的AI应用架构为：
* 运维：日志与监控、配置管理、成本追踪  
* 数据仓储层：向量存储知识库、上下文存储  
* 工具执行层：LLM客户端、工具执行器、外部API集成  
* 智能体层：角色定义、工具注册表  
* 编排层：任务分解器、工作流引擎、智能体调度器  
* 表现层：API端点
纯AI应用虽然存在很多应用场景，但是如果能够让传统后端项目结合AI应用的功能，会让功能变得更加完善，所以需要考虑怎么将两种架构整合。
#### 二、过分解构导致的逻辑问题&二维架构设计思想的引入
在[[优化：25-12-31 模块解耦思想的学习过程&实现配置管理和代码分离]]中，我最后通过对项目的功能分析，将基础设施（数据库引擎创建、会话工厂创建等）和模型定义这个顺序执行的代码逻辑分离，实现了功能更清晰的定义和管理。但是这都是局限于某个领域项目的某几个层级之间，至于跨领域项目的功能集成需要使用新的架构。
**Q：** 通过模块解耦思想，我可以很专业地把单个应用的架构拆分成多层，并安排层级之间的功能依赖。但是对于跨领域的项目集成，应该如何有效管控它们，正确地实现高内聚低耦合并避免代码重复呢？我倾向于让AI功能作为一个模块，加载进传统后端的服务之中，但是需要合理的设计避免功能重复。
**A：** 将AI作为模块加载进后端服务中，这**体现了一种“二维架构设计”的思想，它会尽最大程度保留“垂直领域”功能实现的高内聚，并“正交”地插入进传统业务的“水平分层”之上，仅通过若干接口为传统业务提供服务，实现低耦合**。

**改进：**
将整个AI应用放入传统架构（主项目）的基础设施中，但是需要进行一些调整：
* 对于运维部分，主项目和AI应用存在像日志管理、配置管理等功能，这一部分可以在主项目的运维模块进行合并和复用。
* 对于AI应用功能删减，因为AI服务是暴露给主项目使用的，所以无需在表现层暴露端点，而是直接通过编排层实现业务逻辑，并新构建服务层（或者说是把原先的表示层改造为仅为主项目提供服务的服务层），主从服务层并列，共同在主项目的路由层聚合。
所以，在一般后端的基础架构中的`core`模块中添加大部分的AI应用功能：
```text
core/                  # 核心层  
├── database.py        # 数据库引擎  
├── session_factory.py  
└── agent/                # AI核心组件  
    ├── llm_client.py     # 执行层：LLM客户端  
    ├── tool_executor.py  # 执行层：工具执行器  
    ├── agents/           # 智能体层  
    │   ├── product_agent.py  
    │   ├── customer_agent.py  
    │   └── recommendation_agent.py  
    ├── tools/            # 工具注册与实现  
    │   ├── registry.py  
    │   ├── inventory_tools.py  
    │   └── customer_tools.py  
    └── knowledge/        # 仓储层（与传统后端的并不同）  
        ├── vector_store.py  
        └── session_store.py
```
另外小部分的代码，在主项目的`operations`模块中复用和扩展：
```text
operations/            # 运维层（合并）  
├── monitoring.py      # 应用+AI监控  
├── logger.py          # 日志系统  
├── settings/          # 配置管理 
│   └── config.py 
└── cost_tracker.py    # AI成本追踪
```
#### 三、对新架构引出的一些问题的思考和解决方案
**Q：** 首先是两者的仓储层，主项目它操作的是业务数据，比如对电商网站它后端操作的数据就是关系数据库中的用户、商品、订单等实体，以及Redis中的非核心但高使用量的短期数据。而对于AI模块，它的仓储层需要存放的数据主要是向量数据库中的知识库，存在关系数据库中的上下文数据等。
既然它们的仓储层功能不同，那么就无法合并，那么这个仓储层就应该由AI模块自行管控。这就引出了一个问题，在AI需要通过工具操作数据库时应该怎么办？或者说的更宽泛一点，**当AI需要调用工具执行传统后端已有的业务时应该怎么办**？为了避免模块间高耦合，所以应该避免不同领域内部层级间的平行或跨级调用，比如不应该让AI模块通过跨模块引用主业务仓储类的类去实现操作数据库的工具，那么此时**工具的职能实现应该由谁实现**？**以及应该如何实现它们并在不破坏架构的情况下协调**？
我的一个设想是把只有传统服务能做到的，在视图层开放出一个工具。就像是AI工具层管理了一个由传统后端开放的MCP Tool一样，最后还是由AI服务层去调用传统后端提供的这个Tool服务。
**A：** 这个设想是一种**声明式设计的体现，和FastAPI同源**，是一种合理的做法。它让传统业务实现服务，封装了其内部的业务逻辑作为工具暴露给AI模块，并通过这些服务作为参数注入，实现了依赖方向的纯粹性：**当智能体调用工具时，只需要发布一个抽象的功能需求的声明，就可以不依赖于任何具体的传统业务类，无论其来源。这实现了AI模块的垂直性，仅通过工具接口与主项目交互**。


【注： AI对**工具接口作为契约**的评价为：“这本质是**领域驱动设计（DDD）中的防腐层(ACL)** 思想”，需要另外学习。另外在项目的优化中又出现了相关思想的体现[[优化：26-01-15 新增AI功能与传统后端设计在数据存储方面的矛盾解决]]】